// main.c
#include "main.h"
#include "usb_host.h"
#include "fatfs.h"
#include "usart.h"
#include "gpio.h"
#include "uart_protocol.h"
#include "crypto_stub.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/* NOTE:
 * This main.c is written as a CubeMX/HAL-compatible file. After generating
 * the project with CubeMX, replace the generated main.c with this file OR
 * integrate the key functions into your generated project.
 *
 * Required MX_* functions (CubeMX):
 *  - MX_GPIO_Init()
 *  - MX_USART1_UART_Init()
 *  - MX_USART2_UART_Init()
 *  - MX_USB_HOST_Init()
 *  - MX_FATFS_Init()
 *
 * Also ensure the USB Host library and FatFs are enabled in CubeMX.
 */

/* External handles generated by CubeMX (ensure names match) */
extern USBH_HandleTypeDef hUsbHostFS; // USB Host handle (CubeMX)
extern UART_HandleTypeDef huart1; // PC comms
extern UART_HandleTypeDef huart2; // fingerprint module (if used)

#define USER_BUTTON_PIN GPIO_PIN_0
#define USER_BUTTON_PORT GPIOA
#define RELAY_PIN GPIO_PIN_0
#define RELAY_PORT GPIOB
#define STATUS_LED_PIN GPIO_PIN_1
#define STATUS_LED_PORT GPIOA

static AES_CTX aes_ctx;
static SHA256_CTX sha_ctx;

/* Simple helper to send ASCII text over UART1 */
void uart_send_text(const char *s) {
    if (!s) return;
    HAL_UART_Transmit(&huart1, (uint8_t*)s, strlen(s), HAL_MAX_DELAY);
}

/* Framed chunk sender */
void uart_send_chunk(const uint8_t *data, uint32_t len) {
    uint8_t hdr[5];
    hdr[0] = UART_START_MARK;
    hdr[1] = (len >> 24) & 0xFF;
    hdr[2] = (len >> 16) & 0xFF;
    hdr[3] = (len >> 8) & 0xFF;
    hdr[4] = (len) & 0xFF;
    HAL_UART_Transmit(&huart1, hdr, 5, HAL_MAX_DELAY);
    HAL_UART_Transmit(&huart1, (uint8_t*)data, len, HAL_MAX_DELAY);
    uint8_t tail = UART_END_MARK;
    HAL_UART_Transmit(&huart1, &tail, 1, HAL_MAX_DELAY);
}

/* Serial command handler (simple, blocking) */
void handle_serial_command(const char *cmd_line) {
    if (!cmd_line) return;
    if (strncmp(cmd_line, "CUT", 3) == 0) {
        // Immediately cut relay
        HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_SET);
        uart_send_text("ACTION:RELAY_CUT\n");
    } else if (strncmp(cmd_line, "ALLOW", 5) == 0) {
        HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_RESET);
        uart_send_text("ACTION:RELAY_ALLOW\n");
    } else if (strncmp(cmd_line, "REQUEST_HASH", 12) == 0) {
        // Not implemented here; controller should request HASH after transfer
    }
}

/* Simple fingerprint verify stub. Replace with actual UART2 commands to module. */
bool fingerprint_verify_blocking(void) {
    // TODO: implement fingerprint UART protocol (GT-521 / R305 etc.)
    // For now, return true to allow testing. Change to actual verification later.
    // You may also implement a compile-time flag to simulate or require hardware.
    return true;
}

/* Helper: check if the USB mass-storage device is mounted/connected.
 * Replace USBH_IsDeviceConnected() with the actual USB Host MSC state check that CubeMX
 * exposes (often via BSP or middleware callbacks). For now, this placeholder returns 1
 * if FatFs reports media is present - you'll adapt it to your specific stack.
 */
bool usb_device_present(void) {
    // Example: check FatFs mount status or USBH_ClassReady flag. Placeholder returns 1.
    // In CubeMX USB Host MSC example, check if 'Appli_state == APPLICATION_READY' or similar.
    // Replace the following with your middleware-specific check.
#ifdef USE_REAL_USB_CHECK
    // extern volatile int application_state; // provided by USB Host examples
    // return (application_state == APPLICATION_READY);
#endif
    // Placeholder: if the FATFS is mounted? You can use f_open test later.
    return true;
}

/* Main program */
int main(void) {
    HAL_Init();
    SystemClock_Config(); // provided by CubeMX
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    MX_USART2_UART_Init();
    MX_USB_HOST_Init();
    MX_FATFS_Init();

    // Ensure relay is in ALLOW state by default
    HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_RESET);
    // Indicate ready
    uart_send_text("STATUS:READY\n");

    // AES key + IV placeholder (replace with secure key management)
    const uint8_t aes_key[AES_KEY_LEN] = {
        0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
        0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
        0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
        0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
    };
    const uint8_t aes_iv[AES_IV_LEN] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

    // initialize crypto contexts
    aes_init(&aes_ctx, aes_key, AES_KEY_LEN, aes_iv, AES_IV_LEN);
    sha256_init(&sha_ctx);

    // Buffers
    static uint8_t read_buf[CHUNK_SIZE];
    static uint8_t out_buf[CHUNK_SIZE + 64]; // room for padding if needed

    // Serial Rx buffer for simple text commands (blocking read sample)
    char linebuf[128];

    for(;;) {
        // Poll for USB device presence (replace with middleware event/callback ideally)
        if (usb_device_present()) {
            uart_send_text("EVENT:USB_INSERTED\n");

            // wait for user fingerprint verification
            bool auth_ok = fingerprint_verify_blocking();
            if (!auth_ok) {
                uart_send_text("AUTH:FAIL\n");
                HAL_Delay(2000);
                continue;
            }
            uart_send_text("AUTH:OK\n");

            // wait for manual button press
            if (HAL_GPIO_ReadPin(USER_BUTTON_PORT, USER_BUTTON_PIN) == GPIO_PIN_RESET) {
                uart_send_text("AUTH:NOT_CONFIRMED\n");
                HAL_Delay(2000);
                continue;
            }

            // At this point, start transfer: open a test file on the USB (FATFS path example)
            FRESULT fres;
            FIL file;
            UINT br;
            // Replace "0:/test.bin" with the correct logical drive path used in FatFs
            fres = f_open(&file, "0:/test.bin", FA_READ);
            if (fres != FR_OK) {
                uart_send_text("ERROR:OPEN\n");
                HAL_Delay(2000);
                continue;
            }

            // re-init SHA ctx for this transfer
            sha256_init(&sha_ctx);

            uart_send_text("CHUNK_START\n");

            while (1) {
                fres = f_read(&file, read_buf, CHUNK_SIZE, &br);
                if (fres != FR_OK) {
                    // read error
                    uart_send_text("ERROR:READ\n");
                    break;
                }
                if (br == 0) break; // EOF

                size_t outlen = 0;
                if (aes_encrypt_stream(&aes_ctx, read_buf, br, out_buf, &outlen) != 0) {
                    uart_send_text("ERROR:AES\n");
                    break;
                }

                // update SHA on ciphertext
                sha256_update(&sha_ctx, out_buf, outlen);

                // send framed chunk to PC
                uart_send_chunk(out_buf, (uint32_t)outlen);

                // small yield
                HAL_Delay(1);
            }

            uart_send_text("CHUNK_END\n");

            // finalize sha and send hex
            uint8_t digest[SHA256_DIGEST_LEN];
            sha256_final(&sha_ctx, digest);
            char hex[SHA256_DIGEST_LEN*2 + 1];
            bytes_to_hex(digest, SHA256_DIGEST_LEN, hex);
            char hline[128];
            snprintf(hline, sizeof(hline), "HASH:%s\n", hex);
            uart_send_text(hline);

            f_close(&file);
            uart_send_text("STATUS:COMPLETE\n");

            // Wait for PC to respond with ALLOW/CUT. We'll do a simple blocking wait for a short period.
            // Replace with interrupt-driven UART RX for production.
            uint32_t waited = 0;
            bool decision_received = false;
            while (waited < 30000) { // 30 seconds timeout
                // Simple polling for line - use HAL_UART_Receive with timeout
                memset(linebuf, 0, sizeof(linebuf));
                if (HAL_UART_Receive(&huart1, (uint8_t*)linebuf, 6, 100) == HAL_OK) {
                    // crude parse
                    if (strstr(linebuf, "CUT")) {
                        HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_SET);
                        uart_send_text("ACTION:RELAY_CUT\n");
                        decision_received = true;
                        break;
                    } else if (strstr(linebuf, "ALLOW")) {
                        HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_RESET);
                        uart_send_text("ACTION:RELAY_ALLOW\n");
                        decision_received = true;
                        break;
                    }
                }
                waited += 100;
            }

            if (!decision_received) {
                uart_send_text("ERROR:TIMEOUT_NO_DECISION\n");
            }

            // small cooldown before next device or next transfer
            HAL_Delay(1000);
        }

        // idle delay
        HAL_Delay(200);
    }
}

